#Requires -RunAsAdministrator
#Requires -Version 5.1
Function Invoke-TacticalMSIXDeployment {
    <#
    .DESCRIPTION
        This script installs the WDACConfig MSIX package on the system.
        It does so by securely generating a unique self-signed certificate on the user's system and then using it to sign the MSIX package.
        Everything happens locally and no certificate comes from outside of the device.
        The certificate is added to the Local Machine's Trust Root Certification Authorities Store with only public keys, ensuring no private key exists to be used to sign anything else.
        Its existence with public key is needed so that you can use the WDACConfig app; without it the app will not launch as it will be considered untrusted by the system.
        The 2 files, WDACConfig.dll and WDACConfig.exe inside of the MSIX app installation folder will be added to the Attack Surface Reduction rules exclusion list if they don't already exist in there, so the app will work properly.
        The script creates a new directory in the TEMP directory for its operations and it will be deleted at the end of the script.
        The script checks for the existence of any previous self-signed certificates generated by it and will remove them if it detects any, guaranteeing no unnecessary leftover remains on the user's system.
    .PARAMETER MSIXPath
        Mandatory. The path to the WDACConfig MSIX file
    .PARAMETER SignTool
        Optional. The path to the Microsoft's Signtool.exe
        If not provided, the script automatically downloads the latest SignTool.exe from the Microsoft website in Nuget and will use it for the signing operations.
    .LINK
        https://github.com/HotCakeX/Harden-Windows-Security
    #>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)][System.String]$MSIXPath,
        [Parameter(Mandatory = $False)][System.String]$SignTool
    )
    Begin {
        $script:ErrorActionPreference = 'Stop'

        Write-Verbose -Message 'Creating the working directory in the TEMP directory'
        [System.String]$CommonName = 'SelfSignedCertForWDACConfig'
        [System.String]$WorkingDir = [System.IO.Path]::Combine([System.IO.Path]::GetTempPath(), $CommonName)
        [System.String]$CertificateOutputPath = [System.IO.Path]::Combine($WorkingDir, "$CommonName.cer")
        [System.String]$PFXCertificateOutputPath = [System.IO.Path]::Combine($WorkingDir, "$CommonName.pfx")
        [System.String]$Pass = '123'
        [System.Security.SecureString]$PassSS = ConvertTo-SecureString $Pass -AsPlainText -Force
        [System.String]$HashingAlgorithm = 'Sha512'

        if ([System.IO.Directory]::Exists($WorkingDir)) {
            [System.IO.Directory]::Delete($WorkingDir, $true)
        }
        $null = [System.IO.Directory]::CreateDirectory($WorkingDir)

        Write-Verbose -Message "Checking if a certificate with the common name '$CommonName' already exists."
        [System.String[]]$CertStoresToCheck = @('Cert:\LocalMachine\My', 'Cert:\LocalMachine\Root', 'Cert:\LocalMachine\CA', 'Cert:\LocalMachine\TrustedPublisher', 'Cert:\CurrentUser\My', 'Cert:\CurrentUser\Root', 'Cert:\CurrentUser\CA', 'Cert:\CurrentUser\TrustedPublisher')
        foreach ($Store in $CertStoresToCheck) {
            foreach ($Item in (Get-ChildItem -Path $Store)) {
                if ($Item.Subject -ieq "CN=$CommonName") {
                    Write-Verbose -Message "A certificate with the common name '$CommonName' in the store '$Store' already exists. Removing it."
                    $Item | Remove-Item -Force
                }
            }
        }
    }
    process {
        Write-Verbose -Message 'Building the certificate'
        # Create a hashtable of parameter names and values
        [System.Collections.Hashtable]$Params = @{
            Subject           = "CN=$CommonName"
            FriendlyName      = $CommonName
            CertStoreLocation = 'Cert:\CurrentUser\My'
            KeyExportPolicy   = 'ExportableEncrypted'
            KeyLength         = '4096'
            KeyAlgorithm      = 'RSA'
            HashAlgorithm     = $HashingAlgorithm
            KeySpec           = 'Signature'
            KeyUsage          = 'DigitalSignature'
            KeyUsageProperty  = 'Sign'
            Type              = 'CodeSigningCert'
            NotAfter          = [System.DateTime](Get-Date).AddYears(100)
            TextExtension     = @('2.5.29.19={text}CA:FALSE', '2.5.29.37={text}1.3.6.1.5.5.7.3.3', '1.3.6.1.4.1.311.21.10={text}oid=1.3.6.1.5.5.7.3.3')
        }

        [System.Security.Cryptography.X509Certificates.X509Certificate2]$NewCertificate = New-SelfSignedCertificate @params

        # Save the thumbprint of the certificate to a variable
        [System.String]$NewCertificateThumbprint = $NewCertificate.Thumbprint

        Write-Verbose -Message 'Finding the certificate that was just created by its thumbprint'
        [System.Security.Cryptography.X509Certificates.X509Certificate2]$TheCert = foreach ($Cert in (Get-ChildItem -Path 'Cert:\CurrentUser\My' -CodeSigningCert)) {
            if ($Cert.Thumbprint -eq $NewCertificateThumbprint) {
                $Cert
            }
        }

        Write-Verbose -Message 'Exporting the certificate (public key only)'
        $null = Export-Certificate -Cert $TheCert -FilePath $CertificateOutputPath -Type 'CERT' -Force

        Write-Verbose -Message 'Exporting the certificate (public and private keys)'
        $null = Export-PfxCertificate -Cert $TheCert -CryptoAlgorithmOption 'AES256_SHA256' -Password $PassSS -ChainOption 'BuildChain' -FilePath $PFXCertificateOutputPath -Force

        Write-Verbose -Message "Removing the certificate from the 'Current User/Personal' store"
        $TheCert | Remove-Item -Force

        Write-Verbose -Message "Importing the certificate to the 'Local Machine/Trusted Root Certification Authorities' store with the private key protected by VSM (Virtual Secure Mode - Virtualization Based Security)"
        $null = Import-PfxCertificate -ProtectPrivateKey 'VSM' -FilePath $PFXCertificateOutputPath -CertStoreLocation 'Cert:\LocalMachine\Root' -Password $PassSS

        if ([System.String]::IsNullOrWhiteSpace($SignTool)) {

            Write-Verbose -Message 'Checking if nuget source is available in PowerShell'
            if (-NOT (Get-PackageSource | Where-Object -FilterScript { $_.Name -ieq 'nuget.org' })) {
                Write-Verbose -Message 'Registering the nuget.org package source because it was not found in the system.'
                $null = Register-PackageSource -Name 'nuget.org' -ProviderName 'NuGet' -Location 'https://api.nuget.org/v3/index.json'
            }

            Write-Verbose -Message 'Finding the latest version of the Microsoft.Windows.SDK.BuildTools package from NuGet'

            # Minimum is simply used to limit the number of the fetched packages
            [Microsoft.PackageManagement.Packaging.SoftwareIdentity[]]$Package = Find-Package -Name 'Microsoft.Windows.SDK.BuildTools' -Source 'nuget.org' -AllVersions -Force -MinimumVersion '10.0.22621.3233'
            [Microsoft.PackageManagement.Packaging.SoftwareIdentity]$Package = $Package | Sort-Object -Property { [System.Version]$_.Version } -Descending | Select-Object -First 1

            Write-Verbose -Message 'Downloading SignTool.exe from NuGet...'
            $null = Save-Package -InputObject $Package -Path $WorkingDir -Force

            Write-Verbose -Message 'Extracting the nupkg'
            Expand-Archive -Path "$WorkingDir\*.nupkg" -DestinationPath $WorkingDir -Force

            Write-Verbose -Message 'Detecting the CPU Arch'
            switch ($Env:PROCESSOR_ARCHITECTURE) {
                'AMD64' { [System.String]$CPUArch = 'x64'; break }
                'ARM64' { [System.String]$CPUArch = 'arm64'; break }
                default { Throw [System.PlatformNotSupportedException] 'Only AMD64 and ARM64 architectures are supported.' }
            }

            Write-Verbose -Message 'Finding the Signtool.exe path in the extracted directory'
            $SignTool = "$WorkingDir\bin\*\$CPUArch\signtool.exe"
        }

        # https://learn.microsoft.com/en-us/dotnet/framework/tools/signtool-exe
        Write-Verbose -Message 'Signing the MSIX package'
        . $SignTool sign /debug /n $CommonName /fd $HashingAlgorithm /f $PFXCertificateOutputPath /p $Pass $MSIXPath

        Write-Verbose -Message 'Checking for existence of the application in unpacked format'
        $PossibleExistingApp = Get-AppxPackage -Name 'WDACConfig.AppControl'
        if ($null -ne $PossibleExistingApp) {
            if ($PossibleExistingApp.IsDevelopmentMode -eq $true) {
                if ($PossibleExistingApp.SignatureKind -eq 'None') {
                    # Without this step, the installing would fail
                    Write-Verbose -Message 'The MSIX package is already installed in an unpacked format. Removing it and installing it again from the MSIX file.'
                    $PossibleExistingApp | Remove-AppxPackage -AllUsers
                }
            }
        }

        Write-Verbose -Message 'Installing the MSIX Package'
        # -DeferRegistrationWhenPackagesAreInUse shouldn't be used because then during ASR exclusions the correct path of the application won't be detected and added to the exclusion list
        # -ForceTargetApplicationShutdown will shutdown the application if its open. This step is necessary for ASR rules exclusions later.
        # So either the ASR Rules exclusions must happen or the app gets installed after user closes it
        Add-AppPackage -Path $MSIXPath -ForceUpdateFromAnyVersion -ForceTargetApplicationShutdown

        Write-Verbose -Message "Finding the certificate that was just created by its thumbprint again from the 'Local Machine/Trusted Root Certification Authorities' store"
        [System.Security.Cryptography.X509Certificates.X509Certificate2]$TheCert2 = foreach ($Cert2 in (Get-ChildItem -Path 'Cert:\LocalMachine\Root' -CodeSigningCert)) {
            if ($Cert.Thumbprint -eq $NewCertificateThumbprint) {
                $Cert2
            }
        }

        Write-Verbose -Message 'Removing the certificate that has private + public keys'
        $TheCert2 | Remove-Item -Force

        Write-Verbose -Message "Adding the certificate to the 'Local Machine/Trusted Root Certification Authorities' store with public key only."
        Write-Verbose -Message 'This safely stores the certificate on your device, ensuring its private key does not exist so cannot be used to sign anything else.'
        $null = Import-Certificate -FilePath $CertificateOutputPath -CertStoreLocation 'Cert:\LocalMachine\Root'

        Write-Verbose -Message 'Cleaning up the working directory in the TEMP directory after all tasks have been completed.'
        [System.IO.Directory]::Delete($WorkingDir, $true)

        Write-Verbose -Message 'Finding the WDACConfig.AppControl installation directory'
        [System.String]$InstalledAppLocation = (Get-AppxPackage -Name 'WDACConfig.AppControl').InstallLocation

        Write-Verbose -Message 'Getting the list of Attack Surface Reduction Rules exclusions'
        [System.Collections.Generic.List[System.String]]$CurrentASRExclusions = (Get-MpPreference).AttackSurfaceReductionOnlyExclusions

        foreach ($Item in (Get-ChildItem -Path $InstalledAppLocation -Recurse -Include '*.dll', '*.exe')) {
            if ($Item.Name -in 'WDACConfig.exe', 'WDACConfig.dll') {
                # If the ASR Rules exclusions list is either empty or it doesn't contain the WDACConfig files, then add them
                if ($null -eq $CurrentASRExclusions -or !$CurrentASRExclusions.Contains($Item.FullName)) {
                    Write-Verbose -Message "Adding $($Item.FullName) to the ASR Rules exclusions because it didn't exist there."
                    Add-MpPreference -AttackSurfaceReductionOnlyExclusions $Item.FullName
                }
            }
        }
    }
}

# Get the current folder of this script file
[System.String]$ScriptFilePath = ($MyInvocation.MyCommand.path | Split-Path -Parent)
# Find the latest MSI file
[System.String]$MSIX = Get-Item -Path "$ScriptFilePath\MSIXOutput\WDACConfig*\WDACConfig*.msix" | Sort-Object -Property LastWriteTime -Descending | Select-Object -First 1

Push-Location -Path $ScriptFilePath
Invoke-TacticalMSIXDeployment -MSIXPath $MSIX -Verbose -SignTool .\signtool.exe
Pop-Location
